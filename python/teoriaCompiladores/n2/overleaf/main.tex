\documentclass[conference]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}

\title{Uma Linguagem Específica de Domínio (DSL) para Resolução do Problema da Mochila em Python}

\author{
    \IEEEauthorblockN{Guilherme Cavenaghi - 109317,
    Rafael Godoy - 110453,
    Rafael Pereira de Souza - 109680}
    \IEEEauthorblockA{Centro Universitário FHO\\
    \{guilherme.cavenaghi, rafagodoy330, r.souza\}@alunos.fho.edu.br}
}

\begin{document}

\maketitle

\begin{abstract}
Este trabalho apresenta o desenvolvimento de uma linguagem específica de domínio (DSL) voltada à resolução do Problema da Mochila (Knapsack Problem), utilizando ferramentas de análise léxica e sintática implementadas diretamente em Python. A proposta permite representar instâncias do problema em uma linguagem legível e interpretável, com posterior execução por uma máquina virtual baseada em algoritmos P e NP. O objetivo é estudar a complexidade computacional e aplicar conceitos de teoria da computação em diferentes linguagens formais.
\end{abstract}

\section{Introdução}
O Problema da Mochila 0/1 é um clássico problema de otimização combinatória e pertence à classe NP-completo \cite{martello1990knapsack}. Sua importância teórica e prática motivou a criação de ferramentas de modelagem e resolução. Neste contexto, propomos uma linguagem específica de domínio (DSL) que permite ao usuário descrever instâncias do problema de forma simples, sendo interpretada por um analisador léxico, parser e máquina virtual escritos em Python.

\section{Análise do Artigo-Base}
Inspiramo-nos em trabalhos que utilizam DSLs para modelagem de problemas em logística e produção, adaptando o conceito à modelagem matemática do Knapsack Problem. As abordagens anteriores focam em sistemas WMS, enquanto este trabalho foca em complexidade computacional e algoritmos.

\section{Definição do Novo Contexto}
O problema da mochila é ideal para comparar a aplicabilidade de algoritmos das classes P e NP \cite{cormen2022algorithms}. Criar uma linguagem específica para esse fim permite estudar linguagens formais, gramáticas, autômatos e análise sintática em um contexto prático de TCC e teoria da computação.

\section{Metodologia}

\subsection{Adaptação da Abordagem}
Implementamos o analisador léxico utilizando expressões regulares nativas do Python (re), e o parser foi criado de forma manual, com estruturas condicionais. A entrada da DSL é processada linha a linha, identificando comandos de definição de mochila, itens e execução. A análise sintática é simples e direta, adequada à estrutura restrita da linguagem proposta, que apresenta uma gramática linear e regular, com sentenças formadas por comandos sequenciais e sem aninhamento ou construções recursivas complexas.

\subsection{Exemplo de Entrada da DSL}
\begin{lstlisting}
mochila capacidade=50
item nome=Notebook peso=20 valor=2000
item nome=Livro peso=5 valor=300
item nome=Fone peso=1 valor=500
resolver
\end{lstlisting}

\subsection{Análise Semântica}
A análise semântica verifica que os comandos descritos na linguagem estejam logicamente corretos dentro das regras do domínio. No contexto desta DSL, são avaliados:
\begin{itemize}
    \item Capacidade da mochila deve ser um inteiro positivo;
    \item Cada \texttt{item} deve possuir \texttt{peso} e \texttt{valor} inteiros positivos;
    \item O comando \texttt{resolver} deve existir para acionar a execução.
\end{itemize}
Essas verificações são realizadas após o parser construir a estrutura interna. Caso algum valor inválido seja detectado, o interpretador gera mensagem de erro antes da execução. Não foi implementada uma fase semântica separada, pois a linguagem é restrita e não exige verificação de tipos complexos ou escopos.

\subsection{Desenvolvimento da Aplicação}
\begin{itemize}
    \item Linguagem: Python 3.11
    \item Bibliotecas: \texttt{re} para expressões regulares
    \item Etapas:
    \begin{enumerate}
        \item Definição da gramática da DSL (implícita nas expressões regulares)
        \item Implementação do lexer com \texttt{re}
        \item Implementação do parser com estruturas condicionais
        \item Validação semântica integrada
        \item Resolução do problema com algoritmo exato (programação dinâmica)
    \end{enumerate}
\end{itemize}

\section{Justificativas das Escolhas Técnicas}
Python foi escolhido pela facilidade de prototipagem e por possuir suporte nativo a expressões regulares, facilitando a criação do analisador léxico. A implementação direta do parser simplifica o desenvolvimento, considerando a gramática simples da DSL. A entrada textual permite reusabilidade, clareza e padronização das instâncias.

\section{Resultados}
Resultados preliminares mostram que o tempo de entrada de dados via DSL é reduzido, e a resolução com programação dinâmica apresenta desempenho satisfatório em instâncias pequenas e médias.

\section{Conclusão}
A implementação da DSL permitiu explorar de maneira prática conceitos da teoria da computação, em especial linguagens formais e classes de complexidade. O projeto é extensível para resolução de outros problemas de classes polinomiais.

\section*{Repositório}
Disponível em: \href{https://github.com/Guilherme-del/uniararas/blob/master/python/teoriaCompiladores/n2/proj/main.py}{GitHub}

\bibliographystyle{IEEEtran}
\bibliography{referencias}

\end{document}
