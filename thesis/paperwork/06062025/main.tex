% ------------------------------------------------------------
% Arquivo principal do TCC - Guilherme Cavenaghi
% ------------------------------------------------------------
\documentclass[12pt,oneside,a4paper]{report}

% ----------------- Pacotes -----------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{indentfirst}
\usepackage{setspace}
\usepackage{lmodern}
\usepackage{color}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{url}
\usepackage{geometry}
\usepackage{titlesec}
\geometry{a4paper, margin=2.5cm}

% ----------------- Configurações -----------------
\onehalfspacing
\setlength{\parindent}{1.25cm}
\setlength{\parskip}{0.2cm}

% Remove a palavra "Capítulo" dos títulos dos capítulos
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter}{1em}{}

\title{\textbf{Avaliação Comparativa de Algoritmos em Diferentes Linguagens de Programação: Impacto no Desempenho e Eficiência Computacional}}
\author{Guilherme Cavenaghi \\ RA: 109317 \\ Engenharia da Computação -- 11º Período \\ Centro Universitário Hermínio Ometto - UniAraras}
\date{Março de 2025}

\begin{document}

% ----------------- Folha de rosto -----------------
\begin{titlepage}
    \begin{center}
        \large
        CENTRO UNIVERSITÁRIO HERMINIO OMETTO\\
        UNIARARAS\\[1.5cm]

        \textbf{GUILHERME CAVENAGHI}\\[5cm]

        \textbf{\Large Avaliação Comparativa de Algoritmos em Diferentes Linguagens de Programação: Impacto no Desempenho e Eficiência Computacional}\\[1.5cm]

        Projeto de Trabalho de Conclusão de Curso apresentado ao curso de Engenharia da Computação da Uniararas, como parte dos requisitos para obtenção do grau de Bacharel.\\[0.5cm]

        Orientador: Prof. Renato Luciano Cagnin\\[3cm]

        ARARAS\\
        2025
    \end{center}
\end{titlepage}

% ----------------- Resumo -----------------
\chapter*{Resumo}
Este trabalho tem como objetivo realizar uma análise comparativa de desempenho de algoritmos clássicos implementados em diferentes linguagens de programação. Com base nas linguagens mais utilizadas na indústria e na comunidade acadêmica, serão avaliadas métricas como tempo de execução, uso de memória e complexidade de implementação. A proposta visa identificar como a escolha da linguagem pode influenciar na eficiência computacional de uma aplicação.

\textbf{Palavras-chave:} algoritmos, linguagens de programação, desempenho, eficiência computacional.

% ----------------- Capítulos -----------------

% ----------------- Introdução -----------------
\chapter{Introdução}

O desenvolvimento de software eficiente depende de diversos fatores, e a escolha da linguagem de programação é um dos elementos mais determinantes. Embora a lógica dos algoritmos seja, em essência, independente da linguagem, a forma como são implementados e executados pode variar substancialmente entre diferentes ambientes. Essa variação influencia diretamente o desempenho e a eficiência computacional, afetando aspectos como tempo de execução e uso de memória.

A seleção da linguagem de programação, portanto, não é apenas uma questão de preferência ou familiaridade: trata-se de uma decisão técnica que pode ter impacto significativo em aplicações reais. Este trabalho propõe uma análise comparativa entre linguagens de programação, com foco em algoritmos clássicos de diferentes classes de complexidade (P, NP, NP-completo e NP-difícil). Assume-se que, embora o algoritmo permaneça o mesmo, fatores como o modelo de compilação, o gerenciamento de memória e o runtime variam entre linguagens e podem alterar de forma significativa os resultados observados.

Apesar da existência de benchmarks genéricos, como o TIOBE Index \cite{tiobe}, que indicam a popularidade das linguagens, poucos estudos empíricos abordam de forma prática a comparação de desempenho em algoritmos específicos, considerando dados objetivos como tempo e consumo de memória. Essa lacuna na literatura motiva a realização desta pesquisa, que busca preencher a necessidade de evidências concretas sobre o comportamento de diferentes linguagens em cenários reais.

A justificativa para este estudo reside na crescente demanda por aplicações de alto desempenho e na necessidade de tomar decisões mais embasadas sobre a escolha da linguagem, tanto na academia quanto na indústria. Uma compreensão clara dessas diferenças pode beneficiar desenvolvedores, arquitetos de software e pesquisadores, ajudando-os a selecionar ferramentas alinhadas às necessidades de seus projetos.

A motivação para esta investigação advém da curiosidade de verificar se linguagens tidas como modernas ou populares oferecem, de fato, vantagens práticas em termos de desempenho, ou se tais percepções estão mais ligadas a aspectos culturais e de mercado do que a fatores técnicos.

Os objetivos deste trabalho incluem:
\begin{itemize}
\item Avaliar o desempenho de algoritmos clássicos implementados em diferentes linguagens;
\item Identificar fatores técnicos que afetam esse desempenho, como gerenciamento de memória, modelo de execução e overhead de runtime;
\item Oferecer uma síntese clara de quais linguagens se destacam em cada aspecto analisado.
\end{itemize}

Ao final, será apresentado um resumo dos resultados obtidos nos testes comparativos, destacando pontos fortes e limitações de cada linguagem no contexto dos algoritmos utilizados.

% ----------------- Referencial Teorico -----------------
\chapter{Referencial Teórico}

\section{Algoritmos Clássicos}

Algoritmos são sequências finitas de instruções bem definidas que, partindo de um estado inicial, visam resolver um problema ou realizar uma tarefa específica \cite{cormen2022}. Entre os algoritmos clássicos, destacam-se:

\begin{itemize}
    \item \textbf{MergeSort}: um algoritmo de ordenação eficiente baseado no paradigma "dividir para conquistar", com complexidade \( O(n \log n) \), pertencente à classe P \cite{cormen2022, knuth1998}.
    \item \textbf{Algoritmos de verificação para SAT}: utilizados para validar se uma atribuição satisfaz uma fórmula booleana, caracterizando um problema típico da classe NP \cite{garey1979}.
    \item \textbf{Algoritmos para o Problema da Mochila}: voltados à resolução (exata ou aproximada) de uma seleção ótima de itens, sendo este um problema NP-completo \cite{garey1979}.
    \item \textbf{Modelos de decisão de parada}: que se relacionam com o Problema da Parada, um problema NP-difícil e indecidível, importante na teoria da computação \cite{sipser2012}.
\end{itemize}

\section{Complexidade Computacional}

A análise dos algoritmos considerados neste trabalho será baseada nas classes de complexidade da Teoria da Computação \cite{sipser2012}. Estas classes descrevem o comportamento dos algoritmos em termos de tempo e espaço exigidos conforme o tamanho da entrada cresce.

A classe \textbf{P} representa os problemas que podem ser resolvidos em tempo polinomial por uma máquina determinística \cite{cormen2022}. Já a classe \textbf{NP} representa os problemas cujas soluções podem ser verificadas em tempo polinomial, mesmo que não saibamos resolvê-los de forma eficiente \cite{sipser2012}.

Problemas \textbf{NP-completos} são os mais difíceis dentro da classe NP, e um algoritmo eficiente para qualquer um deles implicaria em uma solução eficiente para todos os problemas NP \cite{garey1979}. Já os \textbf{NP-difíceis} não pertencem necessariamente à classe NP, mas são ao menos tão difíceis quanto os problemas NP-completos \cite{garey1979, sipser2012}.

As definições e análises dos algoritmos implementados neste trabalho serão fundamentadas nessas categorias de complexidade, permitindo compreender não apenas a eficiência empírica, mas também os limites teóricos esperados para cada abordagem em diferentes linguagens de programação.

\subsection{Exemplo de Algoritmo da Classe P}

Um exemplo clássico de algoritmo da classe \textbf{P} é o \textbf{MergeSort}, um algoritmo de ordenação baseado no paradigma "dividir para conquistar", cuja complexidade é \( O(n \log n) \). Este algoritmo sempre resolve o problema de ordenar uma lista em tempo polinomial \cite{cormen2022, knuth1998}.

\subsection{Exemplo de Problema da Classe NP}

Um exemplo de problema da classe \textbf{NP} é o \textbf{Problema de Satisfatibilidade Booleana (SAT)}. Dada uma fórmula booleana composta por variáveis e operadores lógicos, o objetivo é determinar se existe uma atribuição de valores que satisfaça todas as cláusulas \cite{garey1979}. Embora verificar uma solução seja rápido, encontrar uma solução não possui, até o momento, algoritmo determinístico em tempo polinomial.

\subsection{Exemplo de Problema NP-Completo}

\textbf{O Problema da Mochila (Knapsack Problem)} é um exemplo clássico de problema \textbf{NP-completo} \cite{garey1979}. Nele, dado um conjunto de itens, cada um com um peso e um valor, e uma capacidade máxima que a mochila pode suportar, busca-se selecionar os itens de forma que o valor total seja maximizado, sem ultrapassar o limite de peso. Apesar de ser fácil verificar se uma combinação de itens respeita a restrição de peso e calcular seu valor total, encontrar a melhor combinação possível é um desafio computacional ainda sem solução eficiente conhecida.

\subsection{Exemplo de Problema NP-Difícil}

O \textbf{Problema da Parada (Halting Problem)} é um exemplo clássico de problema \textbf{NP-difícil}. Este problema consiste em determinar se um programa de computador, dado um input específico, terminará sua execução ou continuará indefinidamente \cite{sipser2012}. Alan Turing demonstrou que não existe algoritmo capaz de resolver esse problema para todos os casos possíveis, caracterizando-o como indecidível.

\subsection{Resumo das Classes e Exemplos}

A seguir, são apresentados exemplos representativos de algoritmos e problemas relacionados a cada uma das principais classes de complexidade computacional:

\begin{itemize}
    \item \textbf{Classe P}: O \textbf{MergeSort} é um algoritmo de ordenação com tempo polinomial \(O(n \log n)\) \cite{cormen2022, knuth1998}. Ele resolve de forma eficiente o problema de ordenar uma lista de elementos.
    
    \item \textbf{Classe NP}: O \textbf{Problema de Satisfatibilidade Booleana (SAT)} consiste em determinar se existe uma atribuição de valores que satisfaça todas as cláusulas de uma fórmula booleana \cite{garey1979}. Embora a verificação de uma solução seja rápida, encontrar a solução pode ser computacionalmente difícil.
    
    \item \textbf{Classe NP-completo}: O \textbf{Problema da Mochila (Knapsack Problem)} consiste em selecionar, de um conjunto de itens com pesos e valores, aqueles que maximizam o valor total sem ultrapassar a capacidade da mochila \cite{garey1979}. Verificar uma solução é simples, mas encontrar a combinação ótima é computacionalmente complexo.
    
    \item \textbf{Classe NP-difícil}: O \textbf{Problema da Parada (Halting Problem)} questiona se, dado um programa e uma entrada, é possível determinar se o programa terminará ou continuará executando indefinidamente \cite{sipser2012}. Alan Turing provou que este problema é indecidível, ou seja, não existe um algoritmo geral que resolva essa questão para todos os casos.
\end{itemize}

\section{Linguagens de Programação}

As linguagens de programação selecionadas para este estudo foram escolhidas com base em sua ampla adoção e relevância prática, sendo fundamentadas em dados de pesquisas de satisfação e popularidade realizadas por fontes consolidadas da área de tecnologia, como o TIOBE Index \cite{tiobe}, o GitHub Octoverse \cite{octoverse} e o Stack Overflow Developer Survey \cite{stackoverflow}. Esses levantamentos refletem o uso real das linguagens por desenvolvedores ao redor do mundo, bem como sua aceitação, preferência e aplicabilidade em diversos contextos, tanto industriais quanto acadêmicos.

As linguagens consideradas neste trabalho são:

\begin{itemize}
    \item \textbf{Python}: muito utilizada em ciência de dados, inteligência artificial e ensino, destaca-se por sua simplicidade e clareza sintática \cite{sebesta2016}.
    
    \item \textbf{C}: uma linguagem de baixo nível com grande controle sobre recursos computacionais, amplamente utilizada em sistemas embarcados e aplicações de alto desempenho \cite{scott2015}.
    
    \item \textbf{C++}: oferece recursos da linguagem C com suporte adicional à programação orientada a objetos, sendo comum em softwares de engenharia e jogos \cite{sebesta2016}.
    
    \item \textbf{Java}: consolidada em ambientes corporativos e no desenvolvimento Android, reconhecida por sua portabilidade e estabilidade \cite{sebesta2016}.
    
    \item \textbf{JavaScript}: essencial no desenvolvimento web, permite também o desenvolvimento no lado servidor por meio do Node.js \cite{sebesta2016, scott2015}.
    
    \item \textbf{Go}: criada pelo Google, é uma linguagem moderna que combina simplicidade, alto desempenho e excelente suporte à concorrência \cite{scott2015}.
    
    \item \textbf{Rust}: projetada para segurança e performance, tem se destacado em sistemas que exigem controle de memória sem comprometer a robustez \cite{scott2015}.
    
    \item \textbf{TypeScript}: superconjunto de JavaScript com tipagem estática, oferecendo maior previsibilidade e escalabilidade no desenvolvimento de aplicações \cite{scott2015}.
    
    \item \textbf{C\#}: utilizada em aplicações Windows, web e jogos, é fortemente tipada e orientada a objetos, com boa integração no ecossistema .NET \cite{sebesta2016}.
    
    \item \textbf{Kotlin}: moderna, concisa e interoperável com Java, tem sido amplamente adotada no desenvolvimento de aplicações Android \cite{scott2015}.
\end{itemize}

A diversidade entre essas linguagens — em termos de paradigmas, modelos de execução, sistemas de tipos e comunidade de suporte — proporciona uma base sólida e representativa para a análise comparativa do desempenho de algoritmos clássicos, considerando diferentes abordagens de implementação \cite{sebesta2016, scott2015}.

% ----------------- Materiais e Métodos -----------------

\chapter{Materiais e Métodos}

\section{Materiais}

Para a realização deste estudo, foram utilizados os seguintes recursos:

\begin{itemize}
    \item \textbf{Hardware}: Computador pessoal com processador multi-core, arquitetura x64, 16GB de memória RAM, e sistema operacional Linux Ubuntu 22.04.
    \item \textbf{Ambientes de desenvolvimento}: 
    \begin{itemize}
        \item Compiladores e interpretadores específicos de cada linguagem: \textit{GCC} para C e C++, \textit{OpenJDK} para Java, \textit{Python 3.x}, \textit{Node.js} para JavaScript e TypeScript, \textit{Go Compiler}, \textit{Rust Compiler}, \textit{.NET SDK} para C\# e \textit{Kotlin Compiler}.
        \item IDEs e editores: Visual Studio Code, IntelliJ IDEA e terminal de linha de comando.
    \end{itemize}
    \item \textbf{Ferramentas de medição}: 
    \begin{itemize}
        \item Ferramentas internas das linguagens para medição de tempo (por exemplo, \texttt{time}, \texttt{System.nanoTime}, \texttt{performance.now}).
        \item Monitoramento de uso de memória via \texttt{/usr/bin/time} e ferramentas nativas do sistema.
    \end{itemize}
\end{itemize}

Os algoritmos selecionados para este estudo foram implementados de forma equivalente em cada linguagem de programação, respeitando suas características sintáticas, mas preservando a lógica algorítmica original.

\section{Métodos}

\subsection{Seleção dos Algoritmos}

Neste trabalho, foram selecionados algoritmos e problemas clássicos representativos das principais classes de complexidade computacional: P, NP, NP-completo e NP-difícil. A escolha visa permitir uma análise comparativa entre linguagens de programação em diferentes níveis de dificuldade computacional.

Os algoritmos e problemas analisados são:

\begin{itemize}
    \item \textbf{Ordenação (Classe P)}: \textit{MergeSort}.
    
    \item \textbf{Satisfatibilidade Booleana (Classe NP)}: \textit{SAT}.
    
    \item \textbf{Problema da Mochila (Classe NP-completo)}: \textit{Knapsack}.
    
    \item \textbf{Problema da Parada (Classe NP-difícil)}: \textit{Halting Problem}.
\end{itemize}

\subsection{Implementação}

Cada algoritmo foi implementado nas seguintes linguagens de programação:
Python, C,C++,Java, JavaScript, Go, Rust, TypeScript, C\# e Kotlin.  
As implementações buscaram manter a estrutura algorítmica o mais fiel possível, evitando otimizações específicas ou uso de bibliotecas externas que pudessem alterar significativamente o desempenho.

\subsection{Procedimentos de Teste}

Os algoritmos foram executados sobre conjuntos de dados sintéticos, com tamanhos variados para simular diferentes níveis de carga computacional:

\begin{itemize}
    \item Pequeno: 1.000 elementos.
    \item Médio: 10.000 elementos.
    \item Grande: 100.000 elementos.
\end{itemize}

Cada teste foi repetido 30 vezes para reduzir o impacto de variações esporádicas do sistema. Os seguintes parâmetros foram registrados:

\begin{itemize}
    \item \textbf{Tempo de execução}: medido em milissegundos.
    \item \textbf{Uso de memória}: medido em megabytes.
    \item \textbf{Facilidade de implementação}: avaliada qualitativamente com base na extensão e complexidade do código fonte.
\end{itemize}

\subsection{Análise dos Resultados}

Os dados coletados foram organizados em tabelas e gráficos para facilitar a análise comparativa. A avaliação focou em:

\begin{itemize}
    \item Identificação da linguagem com melhor desempenho em cada categoria.
    \item Comparação da eficiência entre linguagens compiladas e interpretadas.
    \item Discussão sobre a relação entre características da linguagem (paradigma, tipagem, compilação) e o desempenho obtido.
\end{itemize}

Os resultados serviram de base para as conclusões acerca do impacto da escolha da linguagem de programação na eficiência computacional dos algoritmos clássicos.

% ----------------- Resultados Esperados -----------------
\chapter{Resultados Esperados}
Espera-se identificar quais linguagens oferecem melhor desempenho para tarefas específicas e como características como paradigma, tipagem e compilação influenciam o comportamento dos algoritmos. Esses dados poderão auxiliar desenvolvedores e pesquisadores na escolha mais adequada de linguagem para projetos com requisitos de desempenho.

% ----------------- Justificativa -----------------
\chapter{Justificativa}
Com a crescente demanda por sistemas eficientes e responsivos, a escolha da linguagem de programação tornou-se um fator crítico no desenvolvimento de software. Embora existam inúmeros estudos sobre algoritmos, poucos se concentram em comparações práticas entre linguagens populares no contexto da eficiência computacional. Este trabalho se justifica pela necessidade de fornecer uma base empírica que auxilie desenvolvedores, estudantes e pesquisadores na tomada de decisões mais conscientes, considerando o impacto direto da linguagem no desempenho final das aplicações.



% ----------------- Referências -----------------
\bibliographystyle{plainnat}
\bibliography{Bibliografia}

\end{document}